{"pages":[{"title":"404","text":"","path":"404/index.html","date":"04-11","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"04-11","excerpt":""},{"title":"关于我","text":"这里是Lnky的个人小站在2019年4月11日，这个特效网站出来了，在看到这个网站的UI时我觉得真的特好看（不是在hexo里面看到的），这个网站本来是 忧郁的弟弟 制作的UI，所以我非常敬佩他，感谢 忧郁的弟弟，同时也感谢制作这个hexo主题的博主 阿里嘎多！！！ 存放一般我会在这里放以前的学习记录与补充学习经验 前身我有一个 yilia 主题的局域网博客，现在更换成gal主题。公网网络安全组地址 : jshz","path":"about/index.html","date":"04-11","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"04-11","excerpt":""}],"posts":[{"title":"python3函数大全","text":"python3函数大全[TOC] 1.abs()绝对值或复数的 abs(-1) &gt;&gt;&gt; 1 2. all()返回一个迭代器, 如果迭代器的所有元素都为真, 那么返回True, 否则返回False all([1, 2, 3,]) &gt;&gt;&gt; True 3. any()接受一个迭代器, 如果迭代器里有一个元素为真, 那么返回True, 否则返回False any([0, 0]) &gt;&gt;&gt; False 4. ascii()调用对象__repr__的方法, 获得该方法的返回值 ascii(&#39;ab&#39;) &gt;&gt;&gt; &quot;&#39;ab&#39;&quot; 5.bin()将十进制转化为二进制 bin(10) &gt;&gt;&gt; &#39;0b1010&#39; 6. bool()测试一个对象是True 还是 False bool([]) &gt;&gt;&gt; False 7.bytearray()字节数组 字节是计算机的语言, 字符串是人类的语言, 它们之间通过编码表形成一一对应的关系 1234567a = 'python'&gt;&gt;&gt; bytearray(a, 'utf-8')bytearray(b'python')&gt;&gt;&gt; list(bytearray(a, 'utf-8'))[112, 121, 116, 104, 111, 110]&gt;&gt;&gt; b'python'[0]112 8.bytes()将一个字符串转换成字节类型 1234st = 'python'a = bytes(st, encoding='utf-8')&gt;&gt;&gt; ab'python' 9.callable()判断对象是否可以被调用, 能被调用的对象就是一个callables对象, 比如函数 callable(str) &gt;&gt;&gt; True 10.chr()查看十进制数对应的ASCII字符 chr(10) &gt;&gt;&gt; &#39;\\n&#39; 11.classmethod()用来指定一个方法为类的方法, 由类直接调用执行, 只有一个cls参数, 执行类的方法时, 自动将调用改方法的类赋值给cls. 没有此参数指定的类的方法为实例方法 12.complie()将字符串编译成python能识别或可以执行的代码, 也可以将文字读成字符串再编译 123456789101112complie(source, filename, mode, flags=0, font_inherit=False, optimize = -1)'''将source编译为代码或者AST对象. 代码对象能够通过exec语句来执行或者eval()进行求值.参数source: 字符串或者AST(abstrace syntax trees)对象.参数filename: 代码文件名称, 如果不是从文件读取代码则传递一些可辨认的值.参数model: 指定编译代码种类. 可以指定'exec', 'eval', 'single'.参数flag 和 dont_inherit: 这两个参数为可选参数'''st = 'python'r = compile(st, '&lt;string&gt;', 'exec')&gt;&gt;&gt; r &lt;code object &lt;module&gt; at 0x00001841735E810, file \"&lt;string&gt;\", line 1&gt; 13.complex()创建一个值为real + imag * j的复数或转化一个字符串或数为复数. 如果第一个参数是字符串, 则不需要指定第二个参数 12complex(1, 2) &gt;&gt;&gt; (1+2j)complex('12') &gt;&gt;&gt; (12+0j) 14.copyright()版权 15.credits()支持 16.delattr()删除对象的属性 17.dict()创建数据字典 dict(a=1) &gt;&gt;&gt; {&#39;a&#39;: 1} 18.dir()不带参数时返回当前范围内的变量, 方法和定义的类型列表, 带参数时返回参数的属性, 方法列表 19.divmod()分别取商和余数 divmod(5, 2) &gt;&gt;&gt; (2, 1) 20.enumerate()返回一个可以枚举的对象, 该对象的next()方法将返回一个元组 12345li = ['a', 'b', 'c']&gt;&gt;&gt; enumerate(li)&lt;enumerate object at 0x0000018417402558&gt;&gt;&gt;&gt; list(enumerate(li))[(0, 'a'), (1, 'b'), (2, 'c')] 21.eval()1.将字符串str当成有效的表达式来求值并返回计算结果 2.去除字符串中内容 1234&gt;&gt;&gt; eval(\"&#123;'a':1&#125;\")&#123;'a':1&#125;&gt;&gt;&gt; eval('1+2+3')6 22.exec()执行字符串或complie方法编译过的字符串, 没有返回值 12345678910111213&gt;&gt;&gt; st ='''z = 4a = x + y + zprint(a)'''&gt;&gt;&gt; exec(st, &#123;'x':0, 'y':0&#125;,&#123;'y':10, 'z':10&#125;)14&gt;&gt;&gt; st = '''a = x + y + zprint(a)&gt;&gt;&gt; exec(st, &#123;'x':0, 'y':0&#125;, &#123;'y':10, 'z': 10&#125;)20 23.exit()退出 24.filter()过滤器, 构造一个序列, 等价于[ item for item in iterables if function(item)], 在函数中设定过滤条件, 逐一函数迭代器中的元素, 将返回值为True的元素留下, 形成filter类型数据 123456789'''filter(function or None, iterable) --&gt; filter object参数function: 返回值为True或False的函数, 可以None参数iterable: 序列可迭代对象'''&gt;&gt;&gt; filter(lambda x:x+1, [1,2])&lt;filter object at 0x00000000021E7128&gt;&gt;&gt;&gt; list(filter(lambda x:x&gt;10, [9, 12])) # filter过滤了一个9, 因为他的条件并不大于10[12] 25.float()讲一个字符串或整数转换为浮点数 12&gt;&gt;&gt; float(11)11.0 26. format()格式化输出字符串, format(value, format_spec)实质上是调用了value的__format__(format_spec)方法 1234&gt;&gt;&gt; format(12)'12'&gt;&gt;&gt; format(12, '5d')' 12' 27.frozenset()创建一个不可修改的集合 1234567'''frozenset([iterable])set和frozenset最本质的区别是前者是可变的, 后者是不可变的. 当集合对象会被改变时(例如删除, 添加元素), 只能用set,一般来说使用frozenset的地方都可以使用set'''&gt;&gt;&gt; frozenset([1,2,3])frozenset(&#123;1, 2, 3&#125;) 28.getattr()获取对象属性 12345678'''getattr(object, name[, default]) -&gt; vaule获取对象object名为name的特性, 如果object不包含为name的特性, 将会抛出AttributeError异常; 如果不包含名为name的特性且提供default参数, 将返回default.参数object: 对象参数name: 对象的特性名参数default: 缺省返回值''' 29.globals()返回一个描述当前全局变量的字典 12345&gt;&gt;&gt; st = 'python'&gt;&gt;&gt; globals()&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'st': 'python'&#125; 30.hasattr()hasattr(object, name)判断对象object是否包含为name的特性 (hasattr是通过调用getattr(object, name)) 是否跑出异常来实现的 12&gt;&gt;&gt; hasattr(list, 'pop')True 31.hash()哈希值hash(object)注意: 可哈希的即不可变数据类型, 不可哈希即可变数据类型 12345678'''如果对象object为哈希表类型, 返回对象object的哈希值. 哈希值为整数, 在字典查找中, 哈希值用于快递比价字典的键.两个数值如果相等, 则哈希值也相等'''&gt;&gt;&gt; hash('ab')-6372704942738210643hash(12)12 32.help()返回对象的帮助文档 123'''调用内建的帮助系统, 如果不好含参数, 交互式帮助系统将在控制台启动. 如果参数为字符串, 则可以是模块, 类, 方法等名称, 并且帮助页面将会在控制台打印. 参数也可以 为任意对象''' 33.hex()将十进制转换为十六进制 12hex(16)&gt;&gt;&gt; '0x10' 34. id()返回对象的内存地址 12&gt;&gt;&gt; id(1)8791166542672 35.input()获取用户输入内容 1234# 获取用户输入的内容, 注意一下, input接收的是str&gt;&gt;&gt; input('请输入: ')请输入: abc'abc' 36.int()讲一个字符串或数值转换为一个普通整数 12345678910111213'''int(x=0) -&gt; integerint(x, base=10) -&gt; integer如果参数是字符串, 那么它可能包含符号和小数点. 参数base代表转换的基数(默认是10进制).他可以是[2, 36]范围内的值, 或者0. 如果是0, 系统将根据字符串内容来解析.如果提供了参数base, 但参数x并不是一个字符串, 将跑出TypeError异常;否则, 参数x必须是数值(普通整数, 长整数, 浮点数). 通过舍去小数点来转换浮点数.如果超出了普通整数的表示范围, 一个长整数被返回.如果没有提供参数, 函数返回0'''&gt;&gt;&gt; int('12')12 37.isinstance()检查对象是否是类的对象, 返回True或False 12&gt;&gt;&gt; isinstance('a', str)True issubclass()检查一个类是否是另一个类的子类. 返回True或False issubclass(sub, super) 12&gt;&gt;&gt; issubclass(str, object)True 39.iter()返回一个iterator对象 12345678910111213141516'''iter(iterable) -&gt; iteratoriter(callable, sentinel) -&gt; iterator'''&gt;&gt;&gt; a = iter([1, 2, 3])next(a)&gt;&gt;&gt; a = iter([1, 2, 3, 4, 5])&gt;&gt;&gt; b = iter(a.__next__,3)&gt;&gt;&gt; next(b)1&gt;&gt;&gt; next(b)2&gt;&gt;&gt; next(b)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;StopIteration 40.len()返回对象长度, 参数可以是序列类型(字符串, 元组或列表) 或映射类型(如字典) 12&gt;&gt;&gt; len([1, 2, 3])3 41.license()软件的历史 42.list()列表构造函数 12&gt;&gt;&gt; list('abc')['a', 'b', 'c'] 43.lcoals()打印当前可用的局部变量的字典 1234&gt;&gt;&gt; locals()&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;&#125; 44. map()对于参数iterable中的每个元素都应用function函数, 并将结果作为列表返回 1234567891011'''如果有多个iterable参数, 那么function函数必须接收多个参数, 这些iterable中相同索引出的元素并行的作为function函数的参数.如果一个iterable中元素的个数比其他少, 那么将用None来扩展iterable是元素个数一致.如果有多个iterable且function为None, map()将返回有元组组成的的列表, 每个元组包含所有iterable中对应索引处值.'''&gt;&gt;&gt; li = [1, 2, 3]&gt;&gt;&gt; a = map(str, li)&gt;&gt;&gt; a&lt;map object at 0x0000000001E878D0&gt;&gt;&gt;&gt; list(a)['1', '2', '3'] 45.max()返回给定元素里最大值 12&gt;&gt;&gt; max(1, 2, 3, 4)4 46.memoryview()本函数是返回对象object的内存查看对象. 所谓内存查看对象,就是对象符合缓冲区协议的对象, 为了给别的代码使用缓冲区里的数据, 而不必拷贝, 就可以直接使用 1234&gt;&gt;&gt; memoryview(b'aabc')&lt;memory at 0x0000000001E0B408&gt;&gt;&gt;&gt; list(memoryview(b'abc'))[97, 98, 99] 47.min()返回给定元素里最小值, 具体用法跟max()相同 12&gt;&gt;&gt; min([1, 2, 3, 4])1 48.next()返回一个可迭代数据结构(如列表)中的下一项 12345&gt;&gt;&gt; a = iter([1, 2, 3, 4])&gt;&gt;&gt; next(a)1&gt;&gt;&gt; next(a)2 49.object()获取一个新的, 无特性(geatureless)对象. Object是所有类的基类. 它提供的方法将在所有的类型实例中共享 50.open() 打开文件open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 52.ord()查看某个ascii对应的十进制 12&gt;&gt;&gt; ord('a')97 53.pow()幂函数pow(x, y, z=None, /) 幂函数, 表示取x得y次幂, 如果存在第三个参数z, 则表示乘方结果对第三个参数取余 1234&gt;&gt;&gt; pow(2, 8)254&gt;&gt;&gt; pow(2, 8, 3)1 54.print()输出函数 55.property()类方法可以当做属性调用 56.quit()退出 57.range()根据需要生成一个指定范围的数字, 可以提供你需要的控制来迭代指定的次数 12&gt;&gt;&gt; list(range(10))[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 58.repr()将任意值转换为字符串, 供计时器读取的形式 59.reversed()反转, 逆序对象 60.round()四舍五入 12&gt;&gt;&gt; round(1.556, 2)1.56 61.set()将对象转换成集合 62.setattr()与getattr()相对应 63.slice()切片功能 123&gt;&gt;&gt; li = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; slice(1, 3, li)slice(1, 3, [1, 2, 3, 4, 5, 6,]) 64.sorted()排序 1234&gt;&gt;&gt; li[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; sorted(li, key = int, reverse=True)[6, 5, 4, 3, 2, 1] 65.staticmethod()方便将外部函数集成到类体中, 梅花代码结构, 重点在不需要类实例化的情况下调用方法 66.str()将字符类型/数值类型等转换为字符串类型 12&gt;&gt;&gt; str(12)'12' 67.sum求和 12&gt;&gt;&gt; sum([1, 2])3 68.super()调用父类的方法 69.tuple()元组构造函数 12&gt;&gt;&gt; tuple([1, 2, 3])(1, 2, 3) 70.type()​ 显示对象所属的类型 12&gt;&gt;&gt; type(1)&lt;class 'int') 71.vars()本函数是实现返回对象object的属性和属性值的字典对象. 如果默认不输入参数, 就打印当前调用位置的属性和属性值, 相当于locals()的功能. 如果有参数输入, 就只打印这个参数相应的属性和属性值 12345678910111213141516171819&gt;&gt;&gt; class ob: i = 1&gt;&gt;&gt; vars(ob)mappingproxy(&#123;'__module__': '__main__', 'i': 1, '__dict__': &lt;attribute '__dict__' of 'ob' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'ob' objects&gt;, '__doc__': None&#125;)&gt;&gt;&gt; a = ob()&gt;&gt;&gt; vars(a)&#123;&#125; #72.zip() 将对象逐一配对&gt;&gt;&gt; li = [1, 2, 3]&gt;&gt;&gt; tu = ('a', 'b', 'c')&gt;&gt;&gt; zip(tu, li)&lt;zip object at 0x0000000001E89A88&gt;&gt;&gt;&gt; list(zip(tu, li))[(1, 'a'), (2, 'b'), (3, 'c')]&gt;&gt;&gt; dict(zip(tu, li))&#123;1: 'a', 2: 'b', 3: 'c'&#125; 如何获取的: 1234&gt;&gt;&gt; li = dir(__builtins__)&gt;&gt;&gt; li = li[li.index('abs'):]&gt;&gt;&gt; for i in range(len(li)): print('#%s.%s()'%(i+1, li[i]))","path":"2019/07/04/python3内置函数/","date":"07-04","excerpt":"","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"day06(控制流程)","text":"前言 python学习的第六天今天的是控制流程 控制流程控制流程的三大执行流程 顺序执行 选择执行 循环执行 123print('----1----')print('----2----')print('----3----') 选择执行1234567891011121314151617181920212223242526272829303132a = 5if a &gt; 3: print('a &gt; 3')elif a == 3: print('a == 3')else: print('a &lt; 3') '''if 条件1: 条件1成立, 需要做的事情elif 条件2: 条件2成立, 需要做的事情elif 条件3: 条件3成立, 需要做的事情else: 以上的条件都不成立, 需要做的事情'''age = 19 # 年龄是18if age &gt; 18: # 如果年龄小于18， 显示如下 print('----0----') print('----1----') print('----2----') print('----3----') print('----4----') print('----5----')print('----6----')# 缩进代表的就是包含关系 拓展1234567891011121314151617181920拓展a = int(input('请输入你的年龄: '))print(type(a))if a &lt;= 18: print(f'你小于18岁, 是一位少先队员')elif 40 &gt; a &gt; 18: # 40小于你的年龄然后你的年龄小于18 print(f'你在40岁与18岁之间, 是一位青少年')else: print(f'你是一位成熟人士') a = 6if a &gt; 5: print(True)else: print(False) print(True) if a &gt; 5 else print(False)# 成立执行值1 if 判断语句 else 不成立执行值2# 简单的判断, 写几行添麻烦, 就可以使用三目运算写成一行 while循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051a = 8if a &gt; 5: print('aaa') # if只执行一次a = 8while a &gt; 5: print('aaa') # while是循环执行， 没有条件会一直执行下去 # 打印 1 到 10 的所有数字i = 1print(i)i += 1print(i)i += 1print(i)i += 1print(i)i += 1print(i)# 这样子太慢了i = 1while i &lt;= 10: print(i) i += 1 # 没有i += 1 就死循环, 就会和上面那个一样\"\"\"while 条件: 条件满足的时候执行的事情先判断, 再执行, 执行完后再回到判断, 直到判断条件不成立, 运行结束\"\"\"# 列表li = [1, 3, 5, 7, 9, 11, 2, 8]i = 0print(li[i])i += 1print(li[i])i += 1print(li[i])i += 1print(li[i])i = 0while i &lt; len(li): if li[i] &gt; 5: print(li[i]) else: print(False) i += 1 拆分然后加起来12345a = ['hello', 'world', '!'] # 拆分print(a[0], a[1], a[2]) # hello world !print('----1----', end='**') # 内容是 ----1---- 结尾是 **print('----2----', end='**')print('----3----', end='**') 跳出循环12345678910111213141516171819202122232425262728li = [1, 3, 5, 7, 9, 11, 2, 8]i = 0while i &lt; len(li): if li[i] == 5: # break #跳出循环, 程序终止, 后面的将不再输出 i += 1 continue # i值进入判断后, continue, 推到while, 而i值始终没有变化, 再次进入判断, 重复之前的动作, 就死循环 if li[i] &gt; 5: print(li[i]) else: print(False) i +=1# break跳出循环, 程序终止# continue跳出当前循环, 进入下一次循环, 注意: 判断条件li = [1, 3, 5, 7, 8]i = 0while i &lt; len(li): if li[i] == 5: i += 1 continue print(li[i]) i += 1else: print('----end----') # else可以跟在while的后面, 但是只有循环结束才会运行else, 如果循环式被break掉的, 那么这个else就不会执行 for 遍历for 的主要应用在遍历 123456789101112131415161718192021222324252627282930313233343536# 列表的遍历li = [1, 3, 5, 7, 9]for i in li: print(i) # 元组的遍历tu = (1, 3, 5, 7, 9)for i in tu: print(i)# 集合的遍历se = &#123;'k1', 'k2', 'k3'&#125;for i in se: print(i) # 字典的遍历dic = &#123;'k1':'v2', 'k2':'v2', 'k3':'v3'&#125;for k, v in dic.items(): # keys 和 values print(k, v)li = [1, 3, 6, 7, 9, 1, 3, 5, 7, 8, 1]for i in li: # 这个遍历的意思是 # li.append(i) # 给li加入i， 但由于i是一个迭代数组， 他就会无限添加到li里边， 和贪吃蛇差不多 print(i)# 如果是可变对象, 一定不要在循环的往里面插入东西# 直接放到for里面# 如果对象有'__iter__'方法, 他就是可迭代的print(dir(li))\"\"\"['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\"\"\"# 第四行有 __iter__ range1234567891011121314151617181920212223li = [1, 3, 6, 7, 9, 1, 3, 5, 7, 8, 1]li.append('a')del(li(2))# range(stop) -&gt; range object# range(strat, stop[, step]) -&gt; range object# 表示的是一个范围print(list(range(5))) # 默认从零开始 切尾 --&gt; [0, 1, 2, 3, 4]print(list(range(1, 5))) # 从1开始 --&gt; [1, 2, 3, 4]print(list(range(1, 5, 2))) # 1到5 --&gt; [1, 3]for i in range(1, 21): print(i) # 跳出循环for i in range(1, 21): if i % 5 == 0: break # 跳出整个循环, 程序终止 # continue # 跳出当前循环, 进入下一次循环 print(i)else: print('----end----')# for break/continue/else 同 while","path":"2019/07/04/day6/","date":"07-04","excerpt":"前言 python学习的第六天今天的是控制流程","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"day05(基本数据类型4)","text":"前言 python学习基础的第五天这个是最后一份基础类型 基础数据类型四s = &#39;北&#39; 当程序执行时， 这个字符会以unicode形式保存到内存空间中(unicode) 编码12345678910s1 = s.encode('utf-8')s2 = s.encode('GBK')print(s)print(s1)print(s2)print(type(s)) # 字符串(str)print(type(s1)) # bytesprint(type(s2)) # bytes 巩固 (指不要停下来啊)1234567891011121314151617181920212223242526a = '你好啊北'# unicode --&gt; GBKunicode_gkb = a.encode('GBK')print(unicode_gkb)# unicode --&gt; utf-8unicode_utf8 = a.encode('utf-8')print(unicode_utf8)# gbk --&gt; utf-8 先解码, 在编码gbk_utf8 = unicode_gkb.decode('GBK').encode('utf-8')print(gbk_utf8)# 总结:\"\"\"1. 各个编码的互相转换都要先转换为unicode, 通过unicode再转其他编码2. GBK不止这一个 ↓\"\"\"unicode_gbk = a.encode('gb18030')print(unicode_gbk)res = unicode_gbk.decode('gb18030')print(res) 赋值赋值: 只是创建一个变量, 该变量指向原来的内存地址 12345678910n2 = n1n1['k1'] = '阿北'print(f'n1: &#123;n1&#125;')print(f'n2: 赋值: &#123;n2&#125;')print('\\n') # 这个是换行n1['k3'][0] = '老蓝'print(f'赋值(dict)_修改: &#123;n1&#125;')print(f'&#123;n2&#125;')print('\\n') # 这个是换行 浅复制在内存中只额外的创建第一层数据 1234567import copyn3 = copy.copy(n1)n1['k1'] = '北白'print(f'&#123;n1&#125;')print(f'浅复制_修改: &#123;n2&#125;')print('\\n') 深拷贝1234n4 = copy.deepcopy(n1)n4['k1'] = '白白'print(f'&#123;n1&#125;')print(f'深拷贝_修改: &#123;n4&#125;') bytes1234567891011print(type('ffff')) # strprint(type(b'ffff')) # bytes# bytes是byte的序列, 字符串是字符的序列# str --&gt; bytess1 = '中'b1 = s1.encode('utf-8') # 英文1个中文3个print(b1)# bytes --&gt; strs2 = b1.decode('utf-8') # 解码print(s2) 拓展str – bytes 1234567# str --&gt; bytess = '老蓝天'b1 = bytes(s, encoding='utf-8')b2 = bytes(s, encoding='GBK')print(f'utf8: &#123;b1&#125;\\nGBK: &#123;b2&#125;')print(type(b1))print(type(b2)) bytes –&gt; str1234# bytes --&gt; strs1 = str(b1, encoding='utf-8')s2 = str(b2, encoding='GBK')print(f'utf8: &#123;s1&#125;\\nGBK: &#123;s2&#125;') bytearray12345678910s1 = '你好,阿北'b1 = bytearray(s1.encode('utf-8'))print(b1)print(type(b1))print(b1.decode('utf-8'))b1[:6] = bytearray('美丽', encoding='utf-8') # 1-6print(b1)print(b1.decode('utf-8')) format (比较长)12345678910111213141516171819202122232425262728293031323334353637%是传统方法, format是python特有year = 2019month = 6day = 18# 格式化日期print('%04d-%02d-%02d' % (year, month, day))f = 3.1415print('%06.2f' % f) # %06.2f 保留宽度为6位, 小数点2位的浮点数, 如果有空位则用0补足print('%o' % 10)print('%02x' % 10)# formattest = 'name: %s, age:%d, nick_name: %s' % ('阿北', 18, '老蓝')print(test)test = 'name: &#123;&#125;, age:&#123;&#125;, nick_name: &#123;&#125;'.format('阿北', 18, '老蓝')print(test)test = 'name: &#123;0&#125;, age:&#123;1&#125;, nick_name: &#123;0&#125;'.format('阿北', 18, '老蓝')print(test)test = 'name: &#123;0&#125;, age:&#123;1&#125;, nick_name: &#123;0&#125;'.format(*['狐狸', 18]) # 解包print(test)print('='*20)test = 'name: &#123;name&#125;, age: &#123;age&#125;, nick_name: &#123;name&#125;'.format(**&#123;'name':'老蓝', 'age':'17'&#125;)print(test)test = 'number: &#123;:b&#125;, &#123;:o&#125;, &#123;:d&#125;, &#123;:x&#125;, &#123;:X&#125;, &#123;:%&#125;'.format(10, 10, 10, 10, 10, 10)print(test)test = 'number: &#123;num:b&#125;, &#123;num:o&#125;, &#123;num:d&#125;, &#123;num:x&#125;, &#123;num:X&#125;, &#123;num:%&#125;'.format(num=1)print(test)test = 'number: &#123;0:b&#125;, &#123;0:o&#125;, &#123;0:d&#125;, &#123;0:x&#125;, &#123;0:X&#125;, &#123;0:%&#125;'.format(10)print(test)print('&#123;:.2f&#125;'.format(3.1415926))","path":"2019/07/04/day5/","date":"07-04","excerpt":"前言 python学习基础的第五天这个是最后一份基础类型","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"day04(基本数据类型3)","text":"前言 python学习基础的第四天笔记本拿去修了(6.18)修到了今天(7.3)才回来.. 内容关于列表、字典、元组和集合那些 基本数据类型三字典123456789D = &#123; 'k1':'v1', 'k2':'v2', 'k3':'v3',&#125;#dict 字典print(D.items()) # --&gt; dict_item([('k1':'v2'&#125;, ('k1':'v2'&#125;, ('k1':'v2'&#125;]) # 键值对print(D.keys()) # --&gt; dict_keys(['k1', 'k2', 'k3]) # key值print(D.values()) # --&gt; dict_values(['v1', 'v2', 'v3']) # value值 获取值第一种方法： 通过key值去取value值 123456789print(D['k1'])D = &#123; 'k1':'v1', 'k2':'v2', 'k3':'v3',&#125;print(D['k1']) # v1 第二种方法 get –&gt; D.get(k[,d]) -&gt; D[k] if k in D, else d. d defaults to None. 1234print(D.get('k3'))print(D.get('k4')) #因为 k4 值不存在print(D)print(D.get('k4', 'false')) # 若值不存在,然后就会返回False 第三种方法 setdefault –&gt; D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D 解释: 通过给定的key查找对应的value值, 如果给定的key==在字典中==,返回对应的==vaule==, 如果不在,返回默认值,同时,在字典中添加了key: 默认值的键对(默认为None,如果设置了d, 则使用d) 12345print(D.setdefault('k1'))print(D.setdefault('k4'))print(D)print(D.setdefault('k5', 'v5'))print(D) 增 （两种）第一种， 通过 key， key有则改， 无则谓1234567891011D = &#123; 'k1':'v1', 'k2':'v2', 'k3':'v3',&#125;print(D['k1'])D['k1'] = 'w'print(D['k1'])D['k4'] = 'v4'print(D) 第二种： setdefault([k].d) # – &gt; 获取, 不会改变key值有则获取， 无则新增 123print(D.setdefault('k3'))print(D.setdefault('k5', 'v5'))print(D) 删除 –&gt; 三种方法 pop popitem clear123456789101112131415161718D = &#123; 'k1':'v1', 'k2':'v2', 'k3':'v3',&#125;a = D.pop('k2')print(a)print(D)# popitem 获取并在字典中移除最后一项b = D.popitem()print(b)print(D)# clear(清空)D.clear()print(D) # &#123;&#125; 集合一个包含唯一元素的可变和无序的集合数据类型 变量初始化， 同列表类似， 元素可以是任何数据类型（排除列表） 12345a = set()print('a的数据类型是:', type(a)) # a的数据类型是set# 注 a = &#123;&#125; 是空字典b = &#123;1, 'a', ()&#125;print('b的数据类型是:', type(b)) 添加(add, update)add123SE = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;SE.add('hello')print(SE) update12SE.update('hello')print(SE) 删除(remove/pop/discrad)remove如果有， 直接删除， 如果无， 报错 123se = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;se.remove(4)print(se) pop随机删除一个集合中的元素， 如果集合没有元素就报错 12se.pop()print(se) discrad如果有， 直接删除， 如果没有， 不做任何的操作 12345se = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;se.discrad(3)print(se)se.discrad(9)print(se) 数据类型交集(&amp;)1234S1 = &#123;1, 2, 5, 7, 10&#125;S2 = &#123;2, 6, 7, 5, 3, 3&#125;S3 = S1 &amp; S2print(f'交集:\\nS1值是:&#123;S1&#125;\\nS2的值是&#123;S2&#125;\\n交集的结果是&#123;S3&#125;\\n') # &#123;2, 10, 5&#125; 并集(|)1234S1 = &#123;1, 2, 5, 8, 10&#125;S2 = &#123;2, 5, 10, 11, 15&#125;S4 = S1 | S2print(f'并集:\\nS1值是:&#123;S1&#125;\\nS2的值是&#123;S2&#125;\\n交集的结果是&#123;S4&#125;\\n') 差集(-)1234S1 = &#123;1, 2, 5, 8, 10&#125;S2 = &#123;2, 5, 10, 11, 15&#125;S5 = S1 - S2print(f'差集:\\nS1值是:&#123;S1&#125;\\nS2的值是&#123;S2&#125;\\n交集的结果是&#123;S5&#125;\\n') 相对差集 ^1234S1 = &#123;1, 2, 5, 8, 10&#125;S2 = &#123;2, 5, 10, 11, 15&#125;S6 = (S1 ^ S2)print(f'相对差集:\\nS1值是:&#123;S1&#125;\\nS2的值是&#123;S2&#125;\\n交集的结果是&#123;S6&#125;\\n') 去重（去掉重复，set就是去重的)1234567T = (1, 2, 3, 4, 5, 5, 4, 6, 3, 8, 9, 7)S1 = set(T) # (1) 转换成 set 去重print(S1)L = list(S1) # 转换成 listprint(L)S2 = set(T) # (2) 转换成 set 去重print(tuple(S2)) # 然后打印转换成 tuple 的 S2 运算符1234567a = 10b = 20print(f'&#123;a+b&#125;\\n&#123;a-b&#125;\\n&#123;a*b&#125;\\n&#123;a/b&#125;\\n&#123;a%b&#125;\\n&#123;a**b&#125;\\n&#123;a//b&#125;\\n')# 5 / 3 = 1..2\"\"\"其中 % 是取余(返回除法的余数), ** 是幂, // 是整除(返回商的整除部分)\"\"\" 比较运算符==, !=, &gt;, &lt;, &gt;=, &lt;= 12345678a = 10b = 20print(a == b) # 等于, Falseprint(a != b) # 不等于, Trueprint(a &gt; b) # 大于, Falseprint(a &lt; b) # 小于, Trueprint(a &gt;= b) # 大于等于, Falseprint(a &lt;= b) # 小于等于, True 赋值运算符=, +=, -=, *=, /=, **=, //= 1234567891011c = a + b # 赋值print(c)c += a # --&gt; c = c + a 先c和a相加,然后再赋值给cprint(c)c -= a # --&gt; c = c - aprint(c)c *= a # 乘等于c /= a # 除等于c %= a # 取余等于c **= a # 幂等于c //= a # 取整除等于 逻辑运算符and, or, not 123print(a and b)print(a or b)print(not a) # False 成员运算符in. not in 1234L = [1, 2, 3]a = 3print(a in L) # Trueprint(a not in L) # False 复习知识list/tuple/dict/set/1234list --&gt; 有序的， 可变， 允许重复的tuple --&gt; 有序的， 不可变的， 允许重复的dict --&gt; 无序的， 可变的， value允许重复， 但key值不能重复set --&gt; 无序的， 重要的 应 用去重 数据类型的创建int12345678910n = 122n = int('122')print(type(n)) # 8791180112496# 为了优化内存,对于 -5 - -257范围内置, 不同变量共用一个内存地址的n = 122n1 = int(122)n2 = 122print(id(n))print(id(n1))print(id(n2)) str1234567891011121314151617181920s = \"\"s = str()s = \"fei\"s = str('fei')print(type(s))# 补充:# 1. 取消转义print('after\\\\none')print(r'after\\noon')print('\\n')# 2. +s1 = \"a\"s2 = \"b\"s3 = s1 + s2print(s3)print(\"1 :\" + s3)print('1:', s3) list12345678li = []li = list()li = [1, 2, 3, 4]li = list([1, 2, 3, 4])print(f'li的type是&#123;type(li)&#125;')name = '老蓝天'li = list(name)print(li) tuple123456t = ()t = tuple()t = tuple([1, 2])t = (11, 22, ['fei', &#123;'k1':'v1'&#125;])print(type(t)) dict123a = &#123;&#125;a = dict(k1=123, k2=456, k3='v3')print(a) set1234s = set()s = &#123;1, 2, 3&#125;l = list(s)print(l)","path":"2019/07/03/day4/","date":"07-03","excerpt":"前言 python学习基础的第四天笔记本拿去修了(6.18)修到了今天(7.3)才回来.. 内容关于列表、字典、元组和集合那些","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"day03(基本数据类型2)","text":"前言 python学习基础的第三天 tips: 代码块里面的代码有些和其他代码块的代码是挂钩的，要注意了 下面代码较多，很多解释都在注释里面 1. 字符串切片，步长，倒序 12345678910111213s = 'Hello,TZ'# H(0)e(1)l(2)l(3)o(4),(5)T(6)Z(7)print(s[2:5]) # lloprint(s[-6:-3]) # ll0，从头往后切print(s[5:2]) # 这里不能交叉取值print(s[0]) # 打印第一个： 0print(s[-8]) # 打印最后一个： Zprint(s[0:5:1]) # 步长为一 打印出来的是Helloprint(s[0:5:2]) # 步长为二 打印出来的是Hloprint(s[::-1]) # 这个为s的倒序print(s[::-2]) # 这个为s的倒序，但是这个是步长为-2 2. 空白移除与切割移除空白strip() 可以使用到left和right –&gt; lstrip、rstrip S.strip([chars]) -&gt; str 这个我看不懂 12345678s1 = ' hello,tz 's = 'hello, tz'print(s)print(s1)print(s1.strip()) # 移除左右两边的空白print(s1.lstrip()) # 移除左边的空白print(s1.rstrip()) # 移除右边的空白print(s1.strip('z')) # 移除左右两边的 'z' 2.1切割1234567# S.split(sep=None, maxsplit = -1) -&gt; list of strings# 切割是直接把指定数给删了然后从那里切割s = 'hello,TZ'print(s.split(',')) # ['hello','TZ']print(s.split()) # 原封不动: ['hello,TZ']print(s.split('l', 1)) # 切一个 'l' : ['hel','lo,TZ']print(s.split('l', 2)) # 切两个 'l' : ['he','o,TZ'] 3.列表(list) 变量初始化 123a = [] # 空列表b = [1, True, 'abc', []] #里面有 int, bool, str, listprint(f'a的类型是: &#123;type(a)&#125;\\nb的类型是: &#123;type(b)&#125;') # a是list b也是list 索引 12L = ['a', 'b', 'c']print(L[0]) 列表是有序的可变的元素集合。 123456789L[0] = 'w' # 更换第一个数成 'w'print(L[0]) # 显示第一个元数print(L) # 显示所有元素print('='*20)S = 'abc'# print(S[0])# S[0] = 'w' 由于这个是一个str，所以不能直接带入到0里面，会报错，只能替换整个str# print(S[0])# print(S) 3.1 长度len()123456print(len(L))#下面是切片L = ['a', 'b', 'c']print(L[:2])print(L[-3:-1]) 4. sort排序123456789# L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*L = ['a', 'c', 'b']L.sort() #正常排序print('正序1: ', L)L.sort(reverse=True) # 逆序print('2 :', L)L.reverse() #正常排序print('3 :', L)print('='*20) 5. 增删改查内容较多 12345678910111213141516171819202122232425262728293031323334# 增删改查# 增L = ['a', 'b', 'c']# 追加：append# 批量追加：extend# 插入：insertL.append('d')print(L)L2 = [1, 2, 3]L.extend(L2)print(L)L.insert(1, 'w')print(L)# 删除# 删掉一个尾巴（后面的数），并把该尾巴可以赋值给另一个变量 --&gt; pop# 删除指定索引元素：del# 清空: cleara = L.pop()print(a)print(L)L.append('w') # 在后面添加'w'print(L)L.remove('w') # 在后面删除'w'print(L)del(L[1]) # 指定删除元素print(L)L.clear() # 清空所有元素print(L) 5.1 包含in (有关bool)12print(a in L) # Trueprint(b in L) # False 6. tuple 元组 123456789# 变量初始化：元素可以是任何类型的数据a = () # 空元组b = (1, False, 'ab', [], ())print(f'a的类型是: &#123;type(a)&#125;\\nb的类型是: &#123;type(b)&#125;') # 两个的类型都为tuple# 注意：单元素元组要注意带上','f = ('hello')g = ('hello',)print(f'f的类型是: &#123;type(f)&#125;\\ng的类型是&#123;type(g)&#125;') # 第一个没有',' 类型是 str, 第二个有',' 类型是 tuple 6.1 索引1234567T = ('a', 'b', 'c')print(T[1]) # 通过索引去取值# T.index(value, [start, [stop]]) -&gt; integer(整数)print(T.index('b')) #通过值去获取索引# T.count(value) -&gt; integerprint(T.count('b')) 6.2 长度len()1print(len(T)) 6.3 切片12print(T[1:])print(T[-2:]) 6.4 包含12345T = ('a', 'b', 'c')a = 'c'b = 'w'print(a in T) # a = 'c', c在T里面，所以结果是 Tprint(b in T) # b = 'w', w不在T里面，所以结果是 F 7. dict(字典)dict 字典 是由键值对构成(key, value)的无序集合（不像字符串，列表和元组那样固定的位置）。 1，&quot;a&quot;, [&#39;ab&#39;, 2, &#39;c&#39;], (&#39;ab&#39;, 2, &#39;c&#39;) 姓名: xf, 密码: 123456 {key: value} 学习过的类型: int/float/complex/bool/str/list/tuple/dict 字典key一般使用数字或者字符串，也可以使用元组，value可以使用任何类型的数据类型 123456789101112131415a = &#123;&#125; # 空字典print(f'a的数据类型是: &#123;type(a)&#125;') # a的数据类型是 dictb = &#123; 1: 2, # key: 数字，value: 数字 'k1': 'v1', # key：字符串，value：字符串 False: True, 'k2': [1, 2, 3], # value: 列表 (1, 2, 3): (1, 2, 3), # key: 元组， value：元组 'k3': &#123; 'k2' :'v2', 'k4': 'v9', 'k5': &#123;&#125; &#125;,&#125;print(f'b的数据类型是: &#123;type(b)&#125;') 总结 7.1 常用功能 还不太懂fromkeys1234567891011121314151617D = &#123; 'k1': 'v1', 'k2': 'v2', 'k3': 'v3',&#125;# D1 = &#123;&#125;# L = [1, 2, 3]# print(D1.fromkeys(L))# print(D1.fromkeys(L, 'v'))# 长度len()print(len(D))# 键、值、键值对print(D.items()) # dict_items(['k1', 'v1'), ('k2', 'v2'), ('k3', 'v3)])print(D.keys()) # dict_keys(['k1', 'k2', 'k3'])print(D.values()) # dict_values(['v1', 'v2', 'v3']) 还未讲到的set常用功能 功能集合 集合总结","path":"2019/06/15/day3/","date":"06-15","excerpt":"前言 python学习基础的第三天 tips: 代码块里面的代码有些和其他代码块的代码是挂钩的，要注意了 下面代码较多，很多解释都在注释里面","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"day02(基本数据类型1)","text":"前言python基础学习第二天 一、基本数据类型​ python的基本数据类型有： 整数、布尔值、字符串、列表、元组、字典、集合 int bool str list tuple dict set 1. 基本操作1234567temp = 'hello't = type(temp)print(t)str #👈 ctrl+左键 点击查看更多help(type(temp)) #可使用的命令具体显示d = dir(temp) #可使用的命令显示print(d) ​ 2.整型（int） 123456789# 整型inta = 88 # 十进制 # a的数据类型是： &lt;class 'int'&gt;b = 0b1110 # 二进制c = 0o57 # 八进制d = 0xa5c # 十六进制print(f'a的数据类型是： &#123;type(a)&#125;\\nb的数据类型是： &#123;type(b)&#125;\\nc的数据类型是： &#123;type(a)&#125;\\nd的数据类型是： &#123;type(a)&#125;\\n')#tips: 32位机器：-2**31~2**31-1；64位：-2**63~2**63-1 整数类型，理论取值范围[-无穷，+无穷], 实际取值范围受限于运行的计算机的内存大小。 3.浮点数（float）12345678a = 0.0b = 75.c = -3.1415926d = 9.8e-2s = 0.1 + 0.2print(s) # 0.30000000000000004print(f's的类型是：&#123;type(s)&#125;\\n')print(f'a的数据类型是： &#123;type(a)&#125;\\nb的数据类型是： &#123;type(b)&#125;\\nc的数据类型是： &#123;type(a)&#125;\\nd的数据类型是： &#123;type(a)&#125;\\n') ​ 课外扩展 1234567# decimal 3.141592696532441*1.23456789import decimala = decimal.Decimal(3.141592696532441)b = decimal.Decimal(1.23456789)decimal.getcontext().prec = 20 # 精确位数print(f'&#123;a * b&#125;\\n') # 3.8785094665974659284 4.复数（complex）123456a = 12.3 + 4jprint('a的数据类型是：', type(a))print(a.real) #实数print(a.imag) #虚数print('='*20)print('\\n') int, float, complex的互相转换123456789101112131415161718192021222324252627282930a = 2b = 3.14c = '2'print(f'a的类型是： &#123;type(a)&#125;\\nb的类型是： &#123;type(b)&#125;\\nc的类型是： &#123;type(c)&#125;\\n')# 转化为整数d = int(b)e = int(c)print(d)print(e)print(f'd的类型是：&#123;type(d)&#125;\\ne的类型是：&#123;type(e)&#125;\\n')# 转化为浮点数f = float(a)g = float(c)print(f)print(g)# 转换复数a = 2b = 3.14c = '2'h = complex(a, b) # 两个参数时，前后都不允许有字符串，否则包错i = complex(b, c) j = complex(c) # 只有单个参数时，才可以使用字符串类型的数字print(h) # (2 + 3.14j)print(i) # (3.14+2j)print(j) # (2+0j)print(type(h)) 5.布尔值 bool: True 和 False1234567891011# 变量初始化a = 2b = 3.14c = '5'd = 0e = \"\"f = Falseg = Noneprint(f'a的布尔值是： &#123;bool(a)&#125;\\nb的布尔值是： &#123;bool(b)&#125;\\nc的布尔值是： &#123;bool(c)&#125;\\nd的布尔值是： &#123;bool(d)&#125;\\n' f'e的布尔值是： &#123;bool(e)&#125;\\nf的布尔值是： &#123;bool(f)&#125;\\ng的布尔值是： &#123;bool(g)&#125;\\n' f'h的布尔值是： &#123;bool(h)&#125;\\ni的布尔值是： &#123;bool(i)&#125;\\nj的布尔值是： &#123;bool(j)&#125;\\n') 6.字符串str12345678910111213141516171819202122字符串str# 变量初始化a = '你好'b = \"hello,world\"c = '''hello,TZ'''d = \"\"\"hello,FF\"\"\"e = \"\"\" 红豆生南国， 春来发几枝？ 愿君多采撷， 此物最相思。 \"\"\"f = ''' 床前明月光， 疑是地上霜。 举头望明月， 低头思故乡。 '''print(f'a： &#123;a&#125;\\nb： &#123;b&#125;\\n' f'c： &#123;c&#125;\\nd： &#123;d&#125;\\n' f'e： &#123;e&#125;\\nf： &#123;f&#125;\\n') 7.（capitalize，center，count，索引，len，切片）12345678910111213141516171819202122print('a的数据类型：', type(a))print(b.capitalize()) #开头大写print(a.center(20, '*')) #居中，若有空白就是用 * 填充# S.count(sub[, start[, end]]) -&gt; intb = \"hello,world\"print(b.count(\"l\")) # 3 是在整个字符串里面有 3 个 lprint(b.count('l', 3)) # 2 是在前三个数（0 - 3)里面找 l ， 有 2 个print(b.count('l', 3, 8)) # 1 在(4 - 8）找 l , 有一个# 索引取值s = 'hello,TZ' #h(0) e(1) l(2) l(3) o(4) ,(5) T(6) Z(7)print(s[0])# 长度len()print(len(s))# 切片# 切片：变量[头下标：尾下标]，不包含尾下标（包头不包尾）print(s[0:2]) #heprint(s[1:4]) #ellprint('这里是：', s[4:1]) # 不能交叉取值， 所以为空值 字符串-功能集","path":"2019/06/14/day2/","date":"06-14","excerpt":"前言python基础学习第二天","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"day01(开学典礼)","text":"前言参加了潭州课堂的python培训加老师微信需要真实姓名, 班期, 学号/账号(我不是打广告哇) 上课时间：周一二，四五八点到八点半 是解答时间 八点半到十点半 是正式课 ​ ==周三，周六== 八点半 是解答课 课程已经在Python入门基础班的章节信息 学习方法多写代码多记笔记 上课的问题标记 思考-&gt;解决-&gt;不行就百度，再不行就提问 Python学院学习环境:https://pan.baidu.com/s/1DerN9l6auNwe0bMGsrDoJA 提取码：3i68 tips: 基础班大部分在windows系统完成，虚拟机先可以不需要 python首选使用pycharm,如果电脑不行，python有自带shell，可以使用 环境安装python添加环境 pycharm免费使用 xshell家庭学生免费使用 虚拟机使用vbox，然后镜像是潭州的乌班图 远程连接使用向日葵","path":"2019/06/13/day1/","date":"06-13","excerpt":"前言参加了潭州课堂的python培训加老师微信需要真实姓名, 班期, 学号/账号(我不是打广告哇)","tags":[{"name":"python","slug":"python","permalink":"https://blog.jshz.top/tags/python/"}]},{"title":"网络欺骗攻击","text":"前言计算机系统及网络的信息安全在越来越先进的社会中越来越凸显地位，在我国，这一问题已引起各方面的高度重视，在与入侵者周旋的过程中，有一种有效的信息安全技术正渐渐进入人们的视野中，这就是网络安全欺骗。 0x1 ARP欺骗ARP（地址解析协议）是在仅知道主机的IP地址是确定其物理地址的一种协议。局域网的网络流通不是根据IP进行，而是按照MAC地址进行传输。 比如局域网内 0x1.1（单向欺骗）A的地址为[IP：10.164.27.30 MAC：AA-AA-AA-AA-AA-AA]B的地址为[IP：10.164.27.40 MAC：BB-BB-BB-BB-BB-BB]C的地址为[IP：10.164.27.50 MAC：CC-CC-CC-CC-CC-CC] A与C进行通信，但是B向A发送了一个自己伪造的 ARP应答，而这个应答中的数据为发送方，IP是 10.164.27.50（C的IP），MAC是BB-BB-BB-BB-BB-BB。（C的MAC本来是CC-CC-CC-CC-CC-CC，这里被伪造了）。当A接收到B的伪ARP应答是，就会更新本地缓存了（A就被欺骗了），B也变成 “C” 了。A与C之间通信的数据就会经过B，B完全可以知道他们之间说了什么，这就是ARP欺骗过程。 掐断A与C之间的通信：B向A发送一条ARP数据包，内容为：C的地址是00:00:00:00:00:00（一个错误的地址），但要注意了，这里只是 A发送给C中断了，C发送给A并没有中断，所以这个叫单向欺骗。 0x1.2（双向欺骗）A与C正常通信，然后B对A说我才是 C，又对C说我才是 A，这样把A和C的ARP缓存表全部修改了。以后的通信过程就是A把数据发给B，B再发送给C；C数据发送给B，B再发送给A。 0x1.3 怎么应对ARP欺骗主机的情况？我们可以使用ARPkiller 的 “Sniffer 杀手” 扫描整个局域网IP段，然后查找处于 “混杂” 模式下的计算机，就可以发现对方了。检测完成后，如果相应的IP是绿帽子图标，说明整个IP处于正常模式，如果是红帽子图标，则说明网卡处于混杂模式，它就是我们的目标，也就是他在用网络执法官捣乱。 0x1.4 DNS欺骗如果可以冒充域名服务器，然后把查询的IP地址设为攻击者的IP地址，用户上网就只能看到攻击者的主页，而不是自己想要取得的网页的主页了，这就是DNS欺骗的基本原理。DNS欺骗其实并不是真的“黑掉”了对方的网站，只是冒名顶替，招摇撞骗罢了。 把攻击这的计算机设成目标域名的代理服务器。这样，外界进入目标的计算机的数据流在黑客的监视之下，黑客可以任意窃听甚至修改数据流里的数据，从而收集大量信息，和IP欺骗相似。 DNS无法在Internet上实现欺骗，只在局域网上有效果。 0x1.5 Web欺骗Web是一种电子信息欺骗，也算障眼法，攻击者复制一个相似的网页与域名，如果眼神不好，在一个相似的网页输入隐私信息与个人账户和密码，就会被后台的黑客所截获到，从而信息泄露。 通常使用这种手段的有引诱，障眼，推荐链接。 实例:引诱全国最大交友网站，快，顶不住了！填写你的信息,以获得大礼包一份姓名：[ ]性别：[ ]住址：[ ] 不要轻易相信这些奇怪的字眼与网站 障眼本来是 https://www.bing.com 的域名，黑客可能会改成www.bing.top 、 www.bimg.com 复制网页一份然后造成障眼，从而获取信息 在进入网页的时候要看到左下角的 js 提示网页，在进入网页的时候要注意有没有输错。 推荐链接推荐链接一般来自好友之间和邮件 0x1.6 网络钓鱼攻击的预防在日常中预防钓鱼攻击，我们应该做到如下几点： 不轻易在网上留下自己身份的任何资料，包括手机号码、身份号、银行号 不要通过网络传输自己的隐私资料，包括手机号码、身份号、银行号 不要轻易相信网上的信息，除非得到了权威的证明。否则千万不要相信别人所传播的谣言 不要在网站注册时透露自己的真实资料，例如，住址、电话、自己的银行卡号 如果涉及金钱交易和商业合同，不要仅仅通过网络完成，有心的骗子可能通过这种途径了解用户的资料。 不要轻易相信电子邮箱、网络论坛等发布的中奖信息、促销信息等，除非得到了另外途径的证明。因为正规的公司一般不会通过电子邮件给用户发送中奖信息和促销信息的。 对电脑进行网络安全防范措施。一是安装防火墙和防病毒软件，并经常升级。二是给系统打补丁，三是禁止浏览器运行Javascript 和 Active 代码，四是不要从网上下载未知来源的软件等。五是提高自我保护意识，不轻易连接公共场所的wifi和商业服务。","path":"2019/03/06/网络欺骗攻击/","date":"03-06","excerpt":"前言计算机系统及网络的信息安全在越来越先进的社会中越来越凸显地位，在我国，这一问题已引起各方面的高度重视，在与入侵者周旋的过程中，有一种有效的信息安全技术正渐渐进入人们的视野中，这就是网络安全欺骗。","tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jshz.top/tags/Web/"}]},{"title":"Netstat","text":"前言记录Netstat 了解网络连接的Netstat命令Netstat是一个监控TCP/IP 网络非常有用的工具，可以显示路由表、实际的网络连接，以及每一个网络接口的状态信息，从而知道哪些网络连接正在运作。 Netstat可显示与 IP、TCP、ICMP 协议相关的统计数据，一般用于检验本机端口的网络连接情况。 计算机有时候接收到的数据报导致出错数据或故障，对此不必感到奇怪，TCP/IP 可以容易允许这些类型的错误并自动重发数据报。但如果累计出错的数目占所接收到的IP数据报相当大的百分比，或者他的数目正在迅速增加，就应该使用Netstat查一查为什么会出现这些情况了。 一般用”netstat -na”命令来显示所有连接的端口并用数字表示。 0x1 参数说明12345678-a: 显示所有活动的 TCP 连接及连接计算机侦听的 TCP 端口和 UDP 端口。-e: 显示以太网 统计信息，如发送和接收的字节数、数据包数。-n: 显示活动的 TCP 连接，但只以数字形式表现地址和端口号，而不确定名称。-o: 显示活动的 TCP 连接并包括每个连接的进程ID(PID).可在Windows任务管理器 \"进程\" 选项卡上找到基于PID的应用程序。该参数可以与-a、-n和-p结合使用。-p: portocol:显示 Protocol 所指定的协议的连接。在这种情况下，Protocol 可以是 TCP、UDP、TCPV6或UDPV6。-s: 按协议显示统计信息。默认情况下，显示TCP、UDP、ICMP 和 IP协议的统计信息。-r: 显示 IP路由表 的内容。该参数与 route print 命令等价。Interval: 每隔 Interval 秒重新显示一次选定的信息。按 \"Ctrl+C\" 组合键可以停止重新显示统计信息。如果省略该参数，Netstat 将只打印一次选定的信息。 语法例子: netstat [-a] [-e] [-n] [-o] [p Protocol] [-r] [-s] 结合上面测试指令吧!!!👆 0x2 典型示例Netstat 命令可显示活动的 TCP 连接、计算机侦听的端口、以太网统计信息、IP 路由表、IPV4 统计信息(对于IP、 ICMP、TCP 和 UDP 协议）以及IPV6 统计信息（对于IPV6、ICMPV6、通过 IPV6 的 TCP 以及通过 IPV6 的UDP协议)。使用时如果不带参数、Netstat将显示活动的 TCP 连接。 下面使用几个 Netstat 的命令的应用实例，如下(1) 显示本机所有活动的 TCP 连接，以及计算机侦听的 TCP 和 UDP 端口，则输入”netstat -a” 命令。 1234C:\\Users\\Administrator&gt;netstat -a活动连接 协议 本地地址 外部地址 状态 TCP 0.0.0.0:80 4L8NNGD38J28N3DNA:0 LISTENING (2)显示服务器活动的 TCP/IP 连接，则应输入 “netstat -n“ 命令或 “netstat“( 不带任何参数 ) 命令。 (3)显示以太网和所有协议的统计信息，则应输入 “netstat -s -e“ 命令。 (4)检查路由表确认路由配置i情况，则应输入 “netstat -rn“ 命令","path":"2019/03/04/Netstat记录/","date":"03-04","excerpt":"前言记录Netstat","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://blog.jshz.top/tags/TCP-IP/"}]},{"title":"Windows注册表","text":"前言在注册表，用户可以添加、删除、修改系统内的软件配置信息或硬件驱动程序，这样就大大方便提升了用户对软、硬件的工作状态进行相应调整。对于黑客来讲，注册表是他们发挥的最大用途之地，例如种植木马，删除硬件信息。 0x1 注册表根项名称和作用 根项名称 作用 HKEY_LOCAL_MACHINE 包括关于本地计算机系统的信息，以及硬件和操作系统数据，如总线类型、系统内存、设备驱动程序和启动控制数据 HKEY_CLASSES_ROOT 包括由各种OLE技术使用的信息和文件类别关联数据。如果在”HKEY_CURRENT_USER\\SOFTW ARE\\Classes”中存在某个键或值，则对应键或值将出现在HKEY_CLASSES_ROOT中 HKEY_CURRENT_USER 包括当前登陆用户的配置文件，如环境变量、桌面设置、网络连接、打印机和程序首选项。这些信息与用户的配置文件相关联 HKEY_USERS 包括关于动态加载的用户配置文件和默认的配置文件的信息。这包含同时出现在HKEY_CURRENT_USER中的信息 HKEY_CURRENT_CONFIG 包含在启动时由本地计算机系统使用的硬件配置文件的相关信息 虽然在注册表中5个根项看上去处于一种并列地位，彼此毫无关系。但事实上，HKEY_CLASSES_ROOT 和 HKEY_CURRENT_CONFIG 中存放的信息，都是HKEY_LOCAL_MACHINE 中存放的信息的一部分；而HKEY_CURRENT_USER中存放的信息，只是HKEY_USERS中存放的信息的一部分。HKEY_LOCAL_MACHINE 包括 HKEY_CLASSES_ROOT 和 HKEY_CURRENT_USER 中的所有信息。Windows 当前定义和使用的数据类型如表所示 0x2 当前定义和使用的数据类型 名称 数据类型 作用 二进制 REG_BINARY 原始二进制数据，大多数硬件组件信息作为二进制数据存储，以十六进制的格式显示在注册表编辑器中 DWORD 值 DWORD 以4字节长（32位整数）的数字表示数据。设备驱动程序和服务的许多参数都是此类型，以二进制、十六进制、和十进制格式显示在注册表编辑器中。与之有关的值是DWORD_LITTLE_ENDIAN（最重要的字节在最低位地址）和REG_FWORD_BIG_ENDIAN（最不重要的字节在最高位地址） 可扩展字符串值 REG_EXPAND_SZ 长度可变的数据字符串，这种数据类型包括程序或服务使用该数据时解析的变量 多字符串值 REG_MULTI_SZ 包含用户可以阅读的列表或多个值，各条目之间用空格、逗号或其他标记分隔 字符串值 REG_SZ 长度固定的文本字符串 二进制值 REG_RESOURCE_LIST 为一系列嵌套的数组，用于存储硬件设备驱动程序或其他控制的某个物理设备所有使用的资源列表 二进制值 REG_RESOURCE_REQUIREMENTS_LIST 一系列嵌套的数组，用于存储一个设备驱动程序（或其控制的某个物理设备）可以使用的硬件资源列表 二进制值 REG_FULL_RESOURCE_DESCRIPTOR 一系列嵌套的数组，用于存储物理硬件设备使用的资源列表 无 REG_NONE","path":"2019/03/04/Windows注册表/","date":"03-04","excerpt":"前言在注册表，用户可以添加、删除、修改系统内的软件配置信息或硬件驱动程序，这样就大大方便提升了用户对软、硬件的工作状态进行相应调整。对于黑客来讲，注册表是他们发挥的最大用途之地，例如种植木马，删除硬件信息。","tags":[{"name":"regedit","slug":"regedit","permalink":"https://blog.jshz.top/tags/regedit/"}]},{"title":"工作组和域的Net命令","text":"前言记录Net命令的学习过程 0x1 Net命令介绍Net 命令是一种基于网络的命令，包括了管理网络环境、服务、用户、登陆等大部分重要的管理功能。常见的 Net 子命令有 net view、net user、net use、net start、net stop、net share等，下面来一一介绍嗷。 1x1 net view作用：显示域列表、计算机列表或指定计算机的共享资源列表。命令格式：net view [\\\\ComputerName] [/domain[:DomainName]] \\\\Computer: 指定要查看其共享资源的计算机名称。/domain[:Domainname]: 指定要查看其可用计算机的域 输入不带参数的 net view，就会显示当前域的计算机列表。实例:net view 127.0.0.1 1x2 net user作用：添加或更改用户账号或显示用户账号信息。该命令也可以写为 net users。命令格式：net user Administrator Administrator 修改已有账号信息输入不带参数的 net user:查看计算机上的用户账号列表。 1x3 net use作用：连接计算机或者断开计算机的共享资源连接，或显示计算机的连接方式 参数介绍：输入不带参数的 net use 查看网络连接 1x4 net start作用：启动服务或显示已启动服务的列表实例：net start server不带参数则显示已启动服务 1x5 net stop作用与上面的 net start 相反 1x6 net share作用：创建、删除或显示共享资源。不带任何参数的 net share 命令： 显示本地计算机上所有共享资源的信息详细请看下面👇Sharename: 共享资源的网络名称drive:path: 指定共享目录的绝对路径。/user:number: 设置可以同时访问共享资源的最大用户数。/unlimited: 不限制同时访问共享资源的用户数。/remark:”test”: 添加关于资源的注释，注释文字用引号引住。","path":"2019/03/04/工作组和域的 Net 命令/","date":"03-04","excerpt":"前言记录Net命令的学习过程","tags":[{"name":"net","slug":"net","permalink":"https://blog.jshz.top/tags/net/"}]},{"title":"Hexo本地服务器创建","text":"前言想方便的设置局域网的个人博客嘛，比设置公网的个人博客简单实用，但还是放个链接吧👇设置公网个人博客 0x1 需要的软件 需要使用的工具:node.jsgit bashHexo 0x2 创建过程打开GitBash，进入你想要存放博客的文件夹，安装Hexo插件:npm install hexo -g 然后初始化文件夹:hexo init 开始下载yilia的主题(主题可选，都行的)：git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia，然后打开站点根目录的_config.yml，找到theme，把原来的主题修改成yilia。 输入hexo clean清楚内存、hexo g更新本地、hexo server -i IP设置你的局域网IP完成。 创建文章：打开GitBash，进入你的站点根目录，输入：hexo new page，就会新建一篇文章，也可以自己在站点根目录文件夹打开source，然后进入_posts新建一个page.md写入文章。 0x03 番外篇个人推荐编写文章的编译器:Markdown 、小书匠 优化与美化可以看DevinZ的，这里就不介绍了。","path":"2019/02/18/内网hexo/","date":"02-18","excerpt":"前言想方便的设置局域网的个人博客嘛，比设置公网的个人博客简单实用，但还是放个链接吧👇设置公网个人博客","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jshz.top/tags/Hexo/"}]},{"title":"Linux系统管理","text":"前言在linux中的每一个文件或目录都包括有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。 0x1 过程r(Read - 读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限w(Write - 写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。x(eXecute - 执行)：对文件而言，具有执行文件的权限；对目录来说该用户具有进入目录的权限。 -(表示不具有该项的权限) 0x2 权限举例-rwx——：文件所有这对文件具有读取、写入和执行的权限。-rw-rw-r-x：文件所有这与同组用户对文件具有读写的权限，而其他用户仅具有读取和执行的权限。drwx–x–x：目录所有着具有读写与进入目录的权限、其他用户可以进入该目录，却无法读取任何数据。Drwx——：除了目录所有者具有完整的权限之外，其他用户对该目录完全没有任何权限。 0x3 特殊权限文件目录权限不止这些，还有所谓的特殊权限。由于特殊权限会拥有一些“特权”，因为用户若无特殊需求，不应该启用这些权限，避免安全方面出现严重漏洞，造成黑客入侵，甚至摧毁系统！！！ s或S(SUID, Set UID)：可执行的文件搭配这个权限，便能获得特权，任意获取该文件的所有者能使用的全部系统资源。所以请注意拥有SUID权限的文件，SUID配root，那就是黑客的任意门 s或S(SGID, Set GIT)：设置在文件上面，其效果与SUID相同，只不过将文件所有者换成用户组，该文件就可以任意存取整个用户组所能使用的系统资源。 t或T(Sticky)：/tmp和/var/tmp目录共所有用户暂时存取文件，就是每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。 对于特殊权限，最好不要设置，不然会带来很严重的安全问题。当然，在这里你也可以改变文件和目录的所有者和所有属。 0x4 详细权限说明文件和目录的权限表示，使用rwx这三个字符来代表所有者、用户组和其他用户的权限。有时候，字符似乎过于麻烦，因此还有另外一种方法就是以数学来表示权限，而且仅需三个数字。 r：对应数值4w：对应数值2x：对应数值1-：对应数值0 数字设定的关键是mode的取值，一开始许多初学者会被搞糊涂，其实很简单，我们将rwx看成二进制数，如果有则有1表示，没有则有0表示，那么rwx r-x r–则可以表示成为：111 101 100再将其每三位转换成为一个十进制数，就是754.例如，我们想让a.txt这个文件的权限为： 自己 同组用户 其他用户可读 是 是 是可写 是 是可执行 那么，我们先根据上表得到权限串为：rw-rw-r–， 那么转换成二进制数就是110 110 100， 再每三位转换成为一个十进制数，就得到664，因此我们执行命令： 1[root@localhost~]# chmod 666 a.txt 按照上面的规则，rwx合起来就是4 + 2 + 1 = 7，一个rwxrwxrwx权限全开放的文件，数值表示为777；而完全不开放权限的文件 “- - - - - - - - -“ 其数字表示为000。 教程转载panyun(有修改)若有侵权，请联系我，我会立刻删除","path":"2019/02/13/Linux文件管理/","date":"02-13","excerpt":"前言在linux中的每一个文件或目录都包括有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jshz.top/tags/Linux/"}]},{"title":"优化与美化","text":"前言总所周知，网站浏览度在于看的人多不多，网站美化好了，自然多人来看。 这里借鉴了几个例子 Alvabill-NexT博客全优化与美化 个性化NexT主题美化 wenbo星空–NexT主题美化(我的主题NexT的美化) yalia主题优化与美化 yalia主题添加阅读量 NexT主题添加背景动态线条 结尾总配置是blog\\_config,而主题配置在blog\\themes\\主题\\_config! 主题配置在theme/next/_config里面 个人觉得yalia主题很好看，自己的博客稀里糊涂的使用了NexT主题搭建，到时候应该也会改成yalia主题的！","path":"2019/02/07/优化与美化/","date":"02-07","excerpt":"前言总所周知，网站浏览度在于看的人多不多，网站美化好了，自然多人来看。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jshz.top/tags/Hexo/"}]},{"title":"初创博客经验","text":"前言很久之前，就打算开始弄一个与搭档的博客，由于技术问题，一直鸽了很久(但后来还是上线了嘛) 博客创建过程(windows) 本咸鱼是使用hexo + github搭建的博客,踩坑过多，故出此与记。 (会的大佬可以直接跳过) 需要使用的工具:node.jsgit bashHexo 大概过程 注册github账号，然后创建仓库 获得ssh，并且使用github账号连接上ssh 安装hexo,并创建hexo init目录, 设置hexo与github关联 上线博客 注册githut账号，创建仓库(图不一样，仅供参考) 进入github官网,注册与登陆账号后，新建一个仓库 create a repository仓库名字要和用户名正确,例如我的是jshz,仓库名字就是jshz.github.io gitbash设置Github账号、邮箱、ssh key连接账号、邮箱打开Git Bash,填写账号信息,输入 git config --global user.name &quot;yourname&quot;(xxx代表你的用户名) 接下来输入git config --global uesr.email &quot;yourname@example.com&quot;(填写你注册时候的邮箱) ssh key查看C:\\Users\\用户 是否有 .ssh，如果有，就备份后删除。 打开GitBash输入ssh key-gen -t rsa -C &quot;yourname@example.com&quot; 生成密钥，后面出现的三个问题都回车。 后面得到两个文件: id_rsa和id_rsa.pub, 打开id_rsa.pub文件, 复制里面的内容。 打开github, 登陆你的账号，点击右上角的下箭头，选择setting,找到SSH and GPG keys,点击New SSH key。提示:添加ssh后，如果不知道ssh是否添加，可以在Git bash使用ssh -t git@github.com测试ssh是否成功添加,如果显示Hi,则代表你成功添加。 waring!!如果没有显示这则消息，那得重新弄一遍了。在这之前，先把C:\\User\\用户 的.ssh删除。github上的ssh密钥也需要清除。接下来回到第二步–&gt;ssh 安装、创建hexo目录、上线博客打开Git Bash, 进入你想要创建博客的文件夹位置, 例如 cd d:/blog,输入npm install hexo -g，开始安装hexo(这里本机已有hexo),输入 hexo init,开始初始化文件夹。 完事之后，安装部署扩展 npm install hexo-deployer-git --save打开d:\\blog\\_config(配置文件)，找到deploy，修改配置如下: 1234deploy: type: git repo: git@github.com:Luxonext/LwJ.git //这个看下面 branch: master repo不用写入上面那行，因为这个是别人的，要填写应该填写你自己的仓库地址。(个人推荐ssh，但需要你的本机ssh与github账户连接才行！) 填写好后，我们可以先预览一下博客hexo s，没有大碍后可以写入public hexo g 然后上线博客hexo d优化与美化会在下一篇写出。 tips:如果hexo d无效，.git 部署什么的话尝试一下 npm install hexo-deployer-git –save因为有时候有些命令维护不能使用，或者更新之后无法找到。 如果是ssh问题建议重新弄一遍ssh 如果是主题问题要仔细看主题作者给出的文档","path":"2018/01/20/创建博客踩坑经验/","date":"01-20","excerpt":"前言很久之前，就打算开始弄一个与搭档的博客，由于技术问题，一直鸽了很久(但后来还是上线了嘛)","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jshz.top/tags/Hexo/"},{"name":"NexT","slug":"NexT","permalink":"https://blog.jshz.top/tags/NexT/"}]}]}